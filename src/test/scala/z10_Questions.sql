
Array

- Sum - https://leetcode.com/problems/two-sum/
- Best Time to Buy and Sell Stock - https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
- Contains Duplicate - https://leetcode.com/problems/contains-duplicate/
- Product of Array Except Self - https://leetcode.com/problems/product-of-array-except-self/
- Maximum Subarray - https://leetcode.com/problems/maximum-subarray/
- Maximum Product Subarray - https://leetcode.com/problems/maximum-product-subarray/
- Find Minimum in Rotated Sorted Array - https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/
- Search in Rotated Sorted Array - https://leetcode.com/problems/search-in-rotated-sorted-array/
- 3Sum - https://leetcode.com/problems/3sum/
- Container With Most Water - https://leetcode.com/problems/container-with-most-water/

---

Binary

- Sum of Two Integers - https://leetcode.com/problems/sum-of-two-integers/
- Number of 1 Bits - https://leetcode.com/problems/number-of-1-bits/
- Counting Bits - https://leetcode.com/problems/counting-bits/
- Missing Number - https://leetcode.com/problems/missing-number/
- Reverse Bits - https://leetcode.com/problems/reverse-bits/

---

Dynamic Programming

- Climbing Stairs - https://leetcode.com/problems/climbing-stairs/
- Coin Change - https://leetcode.com/problems/coin-change/
- Longest Increasing Subsequence - https://leetcode.com/problems/longest-increasing-subsequence/
- Longest Common Subsequence -
- Word Break Problem - https://leetcode.com/problems/word-break/
- Combination Sum - https://leetcode.com/problems/combination-sum-iv/
- House Robber - https://leetcode.com/problems/house-robber/
- House Robber II - https://leetcode.com/problems/house-robber-ii/
- Decode Ways - https://leetcode.com/problems/decode-ways/
- Unique Paths - https://leetcode.com/problems/unique-paths/
- Jump Game - https://leetcode.com/problems/jump-game/

---

Graph

- Clone Graph - https://leetcode.com/problems/clone-graph/
- Course Schedule - https://leetcode.com/problems/course-schedule/
- Pacific Atlantic Water Flow - https://leetcode.com/problems/pacific-atlantic-water-flow/
- Number of Islands - https://leetcode.com/problems/number-of-islands/
- Longest Consecutive Sequence - https://leetcode.com/problems/longest-consecutive-sequence/
- Alien Dictionary (Leetcode Premium) - https://leetcode.com/problems/alien-dictionary/
- Graph Valid Tree (Leetcode Premium) - https://leetcode.com/problems/graph-valid-tree/
- Number of Connected Components in an Undirected Graph (Leetcode Premium) - https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/

---

Interval

- Insert Interval - https://leetcode.com/problems/insert-interval/
- Merge Intervals - https://leetcode.com/problems/merge-intervals/
- Non-overlapping Intervals - https://leetcode.com/problems/non-overlapping-intervals/
- Meeting Rooms (Leetcode Premium) - https://leetcode.com/problems/meeting-rooms/
- Meeting Rooms II (Leetcode Premium) - https://leetcode.com/problems/meeting-rooms-ii/

---

Linked List

- Reverse a Linked List - https://leetcode.com/problems/reverse-linked-list/
- Detect Cycle in a Linked List - https://leetcode.com/problems/linked-list-cycle/
- Merge Two Sorted Lists - https://leetcode.com/problems/merge-two-sorted-lists/
- Merge K Sorted Lists - https://leetcode.com/problems/merge-k-sorted-lists/
- Remove Nth Node From End Of List - https://leetcode.com/problems/remove-nth-node-from-end-of-list/
- Reorder List - https://leetcode.com/problems/reorder-list/

---

Matrix

- Set Matrix Zeroes - https://leetcode.com/problems/set-matrix-zeroes/
- Spiral Matrix - https://leetcode.com/problems/spiral-matrix/
- Rotate Image - https://leetcode.com/problems/rotate-image/
- Word Search - https://leetcode.com/problems/word-search/

---

String

- Longest Substring Without Repeating Characters - https://leetcode.com/problems/longest-substring-without-repeating-characters/
- Longest Repeating Character Replacement - https://leetcode.com/problems/longest-repeating-character-replacement/
- Minimum Window Substring - https://leetcode.com/problems/minimum-window-substring/
- Valid Anagram - https://leetcode.com/problems/valid-anagram/
- Group Anagrams - https://leetcode.com/problems/group-anagrams/
- Valid Parentheses - https://leetcode.com/problems/valid-parentheses/
- Valid Palindrome - https://leetcode.com/problems/valid-palindrome/
- Longest Palindromic Substring - https://leetcode.com/problems/longest-palindromic-substring/
- Palindromic Substrings - https://leetcode.com/problems/palindromic-substrings/
- Encode and Decode Strings (Leetcode Premium) - https://leetcode.com/problems/encode-and-decode-strings/

---

Tree

- Maximum Depth of Binary Tree - https://leetcode.com/problems/maximum-depth-of-binary-tree/
- Same Tree - https://leetcode.com/problems/same-tree/
- Invert/Flip Binary Tree - https://leetcode.com/problems/invert-binary-tree/
- Binary Tree Maximum Path Sum - https://leetcode.com/problems/binary-tree-maximum-path-sum/
- Binary Tree Level Order Traversal - https://leetcode.com/problems/binary-tree-level-order-traversal/
- Serialize and Deserialize Binary Tree - https://leetcode.com/problems/serialize-and-deserialize-binary-tree/
- Subtree of Another Tree - https://leetcode.com/problems/subtree-of-another-tree/
- Construct Binary Tree from Preorder and Inorder Traversal - https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
- Validate Binary Search Tree - https://leetcode.com/problems/validate-binary-search-tree/
- Kth Smallest Element in a BST - https://leetcode.com/problems/kth-smallest-element-in-a-bst/
- Lowest Common Ancestor of BST - https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
- Implement Trie (Prefix Tree) - https://leetcode.com/problems/implement-trie-prefix-tree/
- Add and Search Word - https://leetcode.com/problems/add-and-search-word-data-structure-design/
- Word Search II - https://leetcode.com/problems/word-search-ii/

---

Heap

- Merge K Sorted Lists - https://leetcode.com/problems/merge-k-sorted-lists/
- Top K Frequent Elements - https://leetcode.com/problems/top-k-frequent-elements/
- Find Median from Data Stream - https://leetcode.com/problems/find-median-from-data-stream/
--
Sent from my iPhone
--
Sent from my iPhone





-- The overall work

  Tell him about the end - end work you are doing

  . Couple of KSTream job

  . 15+
  . all data engineer end - end
  . real, time, batch, druid, looker , aws (on prem)
    (picture of a complete data engineer)


-- OPtimization

  . start with the general approach & the specific reason
  . Walk in through an example (3 hour to 0.5 hour)

-- Challenging

  . Bloodhound
  . GA
  . Druid

-- Spark advantage

  .

-- Do u have any question?

  . what kind of challenge?
  .

. Hot partition

Advantage: exactly
disadvan:


  Kafka Architecure
  KStream jobs: what I am doing?
    . Bot filtering
    . user event - visitorid
    . user session - server
    (repartition both by the same key: visitorid)
    (joing these 2 topics)
    (Add session information into userevent)
    (session; 24 hours; session-id, that last for 24 days)
    (visitor_id ; 2 years)
    (visitid: based on 30 min timeout, )
    (sessio is too long ; do not know the motivation of coming back)
    (with visitid we are able to capture the intent or attrib ; is ad, )
    (ad - morning ; email -evening)
    (... vs ...)

    Ask for feedback




--

Assume there is a  employee table and department table
write a sql query to rank the top 3 employees in each department with higher salary

employee: eid, did, salary
department: did, dname

select
  eid,
  did,
  salary
from
  (employee e
  join
  department d
  on e.did = d.did)a
where salary in
  (select salary from employee e2 where e.did = e2.did order by salary desc limit 3)



select
  did,
  eid,
  dense_rank() over (partition by did order by salary desc) as rnk
from
employee e
join
department d
on e.did = d.did
where rnk in (1, 2, 3)

--

The Trips table holds all taxi trips. Each trip has a unique Id, while Client_Id and
Driver_Id are both foreign keys to the Users_Id at the Users table.
Status is an ENUM type of (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’).


--+--------------------+----------+
| Id | Client_Id | Driver_Id | City_Id |        Status      |Request_at|
+----+-----------+-----------+---------+--------------------+----------+
| 1  |     1     |    10     |    1    |     completed      |2013-10-01|
| 2  |     2     |    11     |    1    | cancelled_by_driver|2013-10-01|
| 3  |     3     |    12     |    6    |     completed      |2013-10-01|
| 4  |     4     |    13     |    6    | cancelled_by_client|2013-10-01|
| 5  |     1     |    10     |    1    |     completed      |2013-10-02|
| 6  |     2     |    11     |    6    |     completed      |2013-10-02|
| 7  |     3     |    12     |    6    |     completed      |2013-10-02|
| 8  |     2     |    12     |    12   |     completed      |2013-10-03|
| 9  |     3     |    10     |    12   |     completed      |2013-10-03|
| 10 |     4     |    13     |    12   | cancelled_by_driver|2013-10-03|
+----+-----------+-----------+---------+--------------------+----------+


The Users table holds all users. Each user has an unique Users_Id,
and Role is an ENUM type of (‘client’, ‘driver’, ‘partner’).

+----------+--------+--------+
| Users_Id | Banned |  Role  |
+----------+--------+--------+
|    1     |   No   | client |
|    2     |   Yes  | client |
|    3     |   No   | client |
|    4     |   No   | client |
|    10    |   No   | driver |
|    11    |   No   | driver |
|    12    |   No   | driver |
|    13    |   No   | driver |
+----------+--------+--------+

Write a SQL query to find the cancellation rate of requests made by unbanned users
(both client and driver must be unbanned) between Oct 1, 2013 and Oct 3, 2013.
The cancellation rate is computed by dividing the number of canceled (by client or driver)
requests made by unbanned users by the total number of requests made by unbanned users.

+------------+-------------------+
|     Day    | Cancellation Rate |
+------------+-------------------+
| 2013-10-01 |       0.33        |
| 2013-10-02 |       0.00        |
| 2013-10-03 |       0.50        |
+------------+-------------------+


select
  t.Request_at as Day
  (sum(case when status = 'cancelled_by_driver' then 1 when status = 'cancelled_by_client' then 1 else 0 end) /
    count(*)) as Cancellation_rate
from
  Trips t
  join
  Users u1
  on t.ClientId = u1.Users_Id
  where u1.Banned = "No"
  join
  Users u2
  on t.Driver_Id = u2.Users_Id
  where u2.Banned = "No"
group by t.Request_at
order by t.Request_at



---


Assume there is a customer table
Cust_id
Order table
Order_id,customer_id ,qty
customers who haven’t placed any orders

select
  c.cust_id
from
customer c
left join
order o
on c.cust_id = o.customer_id
where
  o.customer_id is null








Personid  country        city                    state     address
1                Mexico  Mataderos            x            abc
2                  US          Woonsocket            RI         hgf
3                  US          Natick                        MA      ccc
4                   US        Cumberland              RI         ddd

Write a sql query to list the number of persons living in each country.
Only include countries with more than 5 persons

select
  country,
  count(*) as no_of_persons,
from
  table
group by
  country
having
  count(*) > 5



  def returnMismatched(str1: String, str2: String): List[String] = {
    val s1 = str1.split("").filter(!_.isEmpty)
    println(s1.size)
    val s2 = str2.split(" ").filter(!_.isEmpty)
    println(s2.size)
    var result = scala.collection.mutable.ListBuffer[String]()
    s1.foreach{ x =>
      s2.exists(y => x == y) match {
        case true =>
        case false => result.append(x)
      }
    }
    s2.foreach{ x =>
      s1.exists(y => x == y) match {
        case true =>
        case false => result.append(x)
      }
    }

    println(result.mkString(","))
    result.toList
  }


  def return_filled_array(input_lst: List[Any]): List[Any] = {
    var last: Option[Int] = None
    val res = input_lst.isEmpty match {
      case true =>
        println("empty")
        List[Any]()
      case false =>
        input_lst.foldLeft(List[Any]()){ (part, elem) =>
          println(s"element = $elem")
          elem match {
            case None =>
              last match {
                case Some(x) => x :: part
                case None => None :: part
              }
            case x: Int =>
              last = Some(x)
              x :: part
          }
        }
    }
    println(res.reverse.mkString(","))
    res.reverse
  }

  def return_char_num(input_str: String, char: String): Int = {
    val res = input_str.foldLeft(0){ (part: Int, element: Char) =>
      println(s"part = $part, element = $element, char = $char")
      element match {
        case x if x.toString == char =>
          part + 1
        case _ => part
      }
    }
    println("res = " + res)
    res
  }

